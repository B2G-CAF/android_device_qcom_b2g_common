diff --git a/widget/gonk/GonkMemPressure.cpp b/widget/gonk/GonkMemPressure.cpp
new file mode 100644
index 0000000..b212fd6
--- /dev/null
+++ b/widget/gonk/GonkMemPressure.cpp
@@ -0,0 +1,179 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of Code Aurora Forum, Inc. nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "base/basictypes.h"
+#include "nspr/prtypes.h"
+#include "nsCOMPtr.h"
+#include "nsThreadUtils.h"
+#include "nsITimer.h"
+#include "mozilla/Services.h"
+#include "GonkMemPressure.h"
+#include "nsIObserverService.h"
+#include "nsComponentManagerUtils.h"
+#include <android/log.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <poll.h>
+
+#define LOG(args...)  \
+  __android_log_print(ANDROID_LOG_INFO, "GonkMemPressure" , ## args)
+
+// Minimum time between emitting successive memory-pressure events
+#define COOLDOWN_TIME_MS (15*1000) // FIXME: 15s was mostly chosen at random...
+
+using namespace mozilla;
+
+namespace {
+
+class MemPressureRunnable : public nsRunnable
+{
+public:
+  NS_IMETHOD Run()
+  {
+    LOG("Dispatching memory-pressure event");
+    nsCOMPtr<nsIObserverService> obsServ =
+      mozilla::services::GetObserverService();
+    NS_NAMED_LITERAL_STRING(minimize, "heap-minimize");
+    obsServ->NotifyObservers(nullptr, "memory-pressure", minimize.get());
+    return NS_OK;
+  }
+};
+
+
+static nsCOMPtr<nsIThread> sMemPressureThread;
+static nsCOMPtr<nsIRunnable> sRunnable;
+static int sFd;
+
+class MemPressurePoller {
+public:
+  NS_INLINE_DECL_REFCOUNTING(MemPressurePoller);
+
+  MemPressurePoller() {
+    mTimer = do_CreateInstance("@mozilla.org/timer;1");
+
+    // sysfs nodes need to be read before they can be
+    // successfully polled.  Prime MemPressurePoller::Poll()
+    // by trying to perform the first read here
+    char buf[2];
+    read(sFd, buf, 2);
+  }
+
+  static nsCOMPtr<nsIRunnable> GetRunnable()
+  {
+    if (!sRunnable) {
+      sRunnable = NS_NewRunnableMethod(new MemPressurePoller(),
+        &MemPressurePoller::Poll);
+    }
+    return sRunnable;
+  }
+  void Poll();
+
+private:
+  static void TimerDispatch(nsITimer *aTimer, void *aClosure);
+
+  nsCOMPtr<nsITimer> mTimer;
+};
+
+
+void
+MemPressurePoller::Poll()
+{
+  if (sFd <= 0) {
+    return;
+  }
+
+  // Wait for sysfs node to change.
+  struct pollfd fd;
+  fd.fd = sFd;
+  fd.events = POLLERR | POLLPRI;
+  poll(&fd, 1, -1);
+
+  lseek(sFd, 0, SEEK_SET);
+
+  // The notify_trigger_active sysfs node is known to contain two bytes:
+  //     "0\n" or "1\n"
+  char buf[2];
+  int numbytes = read(sFd, buf, 2);
+
+  if (2 == numbytes) {
+    // Emit a "memory-pressure" event if beneath the threshold
+    if ('1' == buf[0]) {
+      NS_DispatchToMainThread(new MemPressureRunnable());
+    }
+  }
+
+  if (mTimer) {
+    LOG("notify_trigger_active cool down timer scheduled");
+    mTimer->Cancel();
+    mTimer->InitWithFuncCallback(TimerDispatch, 0, COOLDOWN_TIME_MS,
+      nsITimer::TYPE_ONE_SHOT);
+  }
+}
+
+/*static*/
+void
+MemPressurePoller::TimerDispatch(nsITimer *aTimer, void *aClosure)
+{
+  sMemPressureThread->Dispatch(MemPressurePoller::GetRunnable(),
+    NS_DISPATCH_NORMAL);
+}
+
+};
+
+
+namespace mozilla {
+
+void
+GonkMemPresureEnable()
+{
+  sFd = open("/sys/kernel/mm/lowmemkiller/notify_trigger_active",
+    O_RDONLY | O_CLOEXEC);
+  if (sFd > 0) {
+    if (sMemPressureThread == nullptr) {
+      NS_NewThread(getter_AddRefs(sMemPressureThread),
+        MemPressurePoller::GetRunnable());
+    }
+  }
+}
+
+void
+GonkMemPresureDisable()
+{
+  if (sFd > 0) {
+    close(sFd);
+    sFd = 0;
+  }
+  sRunnable = nullptr;
+  sMemPressureThread = nullptr;
+}
+
+};
diff --git a/widget/gonk/GonkMemPressure.h b/widget/gonk/GonkMemPressure.h
new file mode 100644
index 0000000..e16433b
--- /dev/null
+++ b/widget/gonk/GonkMemPressure.h
@@ -0,0 +1,39 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=2 et sw=2 tw=80: */
+/* Copyright (c) 2012, Code Aurora Forum. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of Code Aurora Forum, Inc. nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef GONKMEMPRESSURE_H
+#define GONKMEMPRESSURE_H
+
+namespace mozilla {
+void GonkMemPresureEnable();
+void GonkMemPresureDisable();
+}
+
+#endif /* GONKMEMPRESSURE_H */
diff --git a/widget/gonk/Makefile.in b/widget/gonk/Makefile.in
index 30e12bd..02521fe5 100644
--- a/widget/gonk/Makefile.in
+++ b/widget/gonk/Makefile.in
@@ -41,6 +41,7 @@ CPPSRCS	= \
 	nsIdleServiceGonk.cpp \
 	OrientationObserver.cpp \
 	EventHub.cpp \
+	GonkMemPressure.cpp \
 	Input.cpp \
 	InputApplication.cpp \
 	InputDispatcher.cpp \
diff --git a/widget/gonk/nsAppShell.cpp b/widget/gonk/nsAppShell.cpp
index 2e66604..28ccb4f 100644
--- a/widget/gonk/nsAppShell.cpp
+++ b/widget/gonk/nsAppShell.cpp
@@ -43,6 +43,7 @@
 #include "nsScreenManagerGonk.h"
 #include "nsWindow.h"
 #include "OrientationObserver.h"
+#include "GonkMemPressure.h"
 
 #include "android/log.h"
 #include "libui/EventHub.h"
@@ -500,6 +501,7 @@ nsAppShell::~nsAppShell()
     mReaderThread->requestExit();
     mEventHub->wake();
 
+    GonkMemPresureDisable();
     status_t result = mReaderThread->requestExitAndWait();
     if (result)
         LOG("Could not stop reader thread - %d", result);
@@ -521,6 +523,8 @@ nsAppShell::Init()
     rv = AddFdHandler(signalfds[0], pipeHandler, "");
     NS_ENSURE_SUCCESS(rv, rv);
 
+    GonkMemPresureEnable();
+
     // Delay initializing input devices until the screen has been
     // initialized (and we know the resolution).
     return rv;
