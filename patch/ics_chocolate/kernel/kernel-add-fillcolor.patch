diff --git a/drivers/video/msm/mdp_ppp.c b/drivers/video/msm/mdp_ppp.c
index a6f03ba..874952e 100644
--- a/drivers/video/msm/mdp_ppp.c
+++ b/drivers/video/msm/mdp_ppp.c
@@ -1313,40 +1313,125 @@ void put_img(struct file *p_src_file)
 #endif
 }
 
+int mdp_ppp_solid_fill(struct fb_info *info, struct mdp_blit_req *req,
+			unsigned long dst_start, unsigned long dst_len,
+			struct file *p_dst_file)
+{
+	MDPIBUF iBuf;
+	uint8 *dest0, *dest1;
+	uint32 dest0_ystride;
+	uint32 dst_roi_width;
+	uint32 dst_roi_height;
+	uint32 dst_packPattern, ppp_dst_cfg_reg;
+	struct msm_fb_data_type *mfd = info->par;
+	dest1 = NULL;
+
+	down(&mdp_ppp_mutex);
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_ON, FALSE);
+	req->dst_rect.w = ((req->dst_rect.w/2) * 2);
+	iBuf.ibuf_width = req->dst.width;
+	iBuf.ibuf_height = req->dst.height;
+	iBuf.bpp = bytes_per_pixel[req->dst.format];
+	iBuf.ibuf_type = req->dst.format;
+	iBuf.buf = (uint8 *) dst_start;
+	iBuf.buf += req->dst.offset;
+	iBuf.roi.lcd_x = req->dst_rect.x;
+	iBuf.roi.lcd_y = req->dst_rect.y;
+	iBuf.roi.dst_width = req->dst_rect.w;
+	iBuf.roi.dst_height = req->dst_rect.h;
+
+	if (iBuf.ibuf_type == MDP_BGRA_8888)
+		dst_packPattern =
+		    MDP_GET_PACK_PATTERN(CLR_ALPHA, CLR_R, CLR_G, CLR_B,
+					 8);
+	else if (iBuf.ibuf_type == MDP_RGBA_8888 ||
+			 iBuf.ibuf_type == MDP_RGBX_8888)
+		dst_packPattern =
+		    MDP_GET_PACK_PATTERN(CLR_ALPHA, CLR_B, CLR_G, CLR_R,
+					 8);
+	else if (iBuf.ibuf_type == MDP_XRGB_8888)
+		dst_packPattern =
+		    MDP_GET_PACK_PATTERN(CLR_ALPHA, CLR_R, CLR_G, CLR_B,
+					 8);
+	else
+		dst_packPattern =
+		    MDP_GET_PACK_PATTERN(CLR_ALPHA, CLR_R, CLR_G, CLR_B,
+					 8);
+
+	ppp_dst_cfg_reg = PPP_DST_C0G_8BIT |
+	    PPP_DST_C1B_8BIT |
+	    PPP_DST_C2R_8BIT |
+	    PPP_DST_C3A_8BIT |
+	    PPP_DST_C3ALPHA_EN |
+	    PPP_DST_PACKET_CNT_INTERLVD_4ELEM |
+	    PPP_DST_PACK_TIGHT |
+	    PPP_DST_PACK_ALIGN_LSB |
+	    PPP_DST_OUT_SEL_AXI |
+	    PPP_DST_BPP_4BYTES | PPP_DST_PLANE_INTERLVD;
+
+	dest0_ystride = iBuf.ibuf_width * iBuf.bpp;
+	dst_roi_width = iBuf.roi.dst_width;
+	dst_roi_height = iBuf.roi.dst_height;
+	dest0 = (uint8 *) iBuf.buf;
+	dest1 = mdp_get_chroma_addr(&iBuf);
+
+	mdp_adjust_start_addr(&dest0, &dest1, 1, 1,
+			      iBuf.roi.lcd_x, iBuf.roi.lcd_y,
+			      iBuf.ibuf_width, iBuf.ibuf_height, iBuf.bpp,
+			      &iBuf, 2);
+
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0138, 0x10000000);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0108, (dst_roi_height << 16 |
+					      dst_roi_width));
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0124, ppp_dst_cfg_reg);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0128, dst_packPattern);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x014c, 0xffffffff);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0150, ppp_dst_cfg_reg);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0154, dst_packPattern);
+	MDP_OUTP(MDP_BASE + 0x20004, 0x2);
+	MDP_OUTP(MDP_BASE + 0x20040, req->const_color.g |
+		req->const_color.b << 8 | req->const_color.r << 16 |
+			req->const_color.alpha << 24);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0164,
+		 (dst_roi_height << 16 | dst_roi_width));
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0168, dest0);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x016c, dest1);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0178,
+		 (dest0_ystride << 16 | dest0_ystride));
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x01b8, 0);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x01bc, 0);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x013c, 0);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0140, 0);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0144, 0);
+	MDP_OUTP(MDP_CMD_DEBUG_ACCESS_BASE + 0x0148, 0);
+
+	mdp_pipe_kickoff(MDP_PPP_TERM, mfd);
+
+	MDP_OUTP(MDP_BASE + 0x20004, 0x0);
+	mdp_pipe_ctrl(MDP_CMD_BLOCK, MDP_BLOCK_POWER_OFF, FALSE);
+	up(&mdp_ppp_mutex);
+
+	put_img(p_dst_file);
+	return 0;
+
+}
+
+static int mdp_ppp_blit_addr(struct fb_info *info, struct mdp_blit_req *req,
+	unsigned long src_start, unsigned long src_len,
+	unsigned long srcp1_start, unsigned long srcp1_len,
+	unsigned long dst_start, unsigned long dst_len,
+	struct file *p_src_file, struct file *p_dst_file)
 
-int mdp_ppp_blit(struct fb_info *info, struct mdp_blit_req *req)
 {
-	unsigned long src_start, dst_start;
-	unsigned long src_len = 0;
-	unsigned long dst_len = 0;
 	MDPIBUF iBuf;
 	u32 dst_width, dst_height;
-	struct file *p_src_file = 0 , *p_dst_file = 0;
-	struct msm_fb_data_type *mfd = (struct msm_fb_data_type *)info->par;
+	struct msm_fb_data_type *mfd = info->par;
 
 	if (req->dst.format == MDP_FB_FORMAT)
 		req->dst.format =  mfd->fb_imgType;
 	if (req->src.format == MDP_FB_FORMAT)
 		req->src.format = mfd->fb_imgType;
-	if (req->flags & MDP_BLIT_SRC_GEM)
-		get_gem_img(&req->src, &src_start, &src_len);
-	else
-		get_img(&req->src, info, &src_start, &src_len, &p_src_file);
-	if (src_len == 0) {
-		printk(KERN_ERR "mdp_ppp: could not retrieve image from "
-		       "memory\n");
-		return -1;
-	}
-	if (req->flags & MDP_BLIT_DST_GEM)
-		get_gem_img(&req->dst, &dst_start, &dst_len);
-	else
-		get_img(&req->dst, info, &dst_start, &dst_len, &p_dst_file);
-	if (dst_len == 0) {
-		put_img(p_src_file);
-		printk(KERN_ERR "mdp_ppp: could not retrieve image from "
-		       "memory\n");
-		return -1;
-	}
+
 	if (mdp_ppp_verify_req(req)) {
 		printk(KERN_ERR "mdp_ppp: invalid image!\n");
 		put_img(p_src_file);
@@ -1589,3 +1674,40 @@ int mdp_ppp_blit(struct fb_info *info, struct mdp_blit_req *req)
 	put_img(p_dst_file);
 	return 0;
 }
+
+int mdp_ppp_blit(struct fb_info *info, struct mdp_blit_req *req)
+{
+	unsigned long src_start, dst_start;
+	unsigned long src_len = 0;
+	unsigned long dst_len = 0;
+	struct file *p_src_file = 0 , *p_dst_file = 0;
+
+	if (!(req->flags & CONST_COLOR)) {
+		if (req->flags & MDP_BLIT_SRC_GEM)
+			get_gem_img(&req->src, &src_start, &src_len);
+		else
+			get_img(&req->src, info, &src_start, &src_len, &p_src_file);
+		if (src_len == 0) {
+			printk(KERN_ERR "mdp_ppp: could not retrieve image from "
+			       "memory\n");
+			return -EINVAL;
+		}
+	}
+	if (req->flags & MDP_BLIT_DST_GEM)
+		get_gem_img(&req->dst, &dst_start, &dst_len);
+	else
+		get_img(&req->dst, info, &dst_start, &dst_len, &p_dst_file);
+	if (dst_len == 0) {
+		put_img(p_src_file);
+		printk(KERN_ERR "mdp_ppp: could not retrieve image from "
+		       "memory\n");
+		return -EINVAL;
+	}
+
+	if (req->flags & CONST_COLOR)
+		return mdp_ppp_solid_fill(info, req, dst_start,
+						dst_len, p_dst_file);
+	else
+		return mdp_ppp_blit_addr(info, req, src_start, src_len, 0, 0, dst_start,
+					 dst_len, p_src_file, p_dst_file);
+}
diff --git a/include/linux/msm_mdp.h b/include/linux/msm_mdp.h
index cf4925b..13c2a22 100644
--- a/include/linux/msm_mdp.h
+++ b/include/linux/msm_mdp.h
@@ -120,6 +120,7 @@ enum {
 #define MDP_FLIP_LR 0x1
 #define MDP_FLIP_UD 0x2
 #define MDP_ROT_90 0x4
+#define CONST_COLOR 0x0000100
 #define MDP_ROT_180 (MDP_FLIP_UD|MDP_FLIP_LR)
 #define MDP_ROT_270 (MDP_ROT_90|MDP_FLIP_UD|MDP_FLIP_LR)
 #define MDP_DITHER 0x8
@@ -207,11 +208,19 @@ struct mdp_csc {
 
 #define MDP_BLIT_REQ_VERSION 2
 
+struct color {
+	uint32_t r;
+	uint32_t g;
+	uint32_t b;
+	uint32_t alpha;
+};
+
 struct mdp_blit_req {
 	struct mdp_img src;
 	struct mdp_img dst;
 	struct mdp_rect src_rect;
 	struct mdp_rect dst_rect;
+	struct color const_color;
 	uint32_t alpha;
 	uint32_t transp_mask;
 	uint32_t flags;
